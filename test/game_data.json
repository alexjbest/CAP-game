{"name": "Lean CAP game", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Lean CAP game-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": false}, {"type": "lean", "content": "7", "hidden": true}, {"type": "text", "content": "8"}, {"type": "tactic", "content": "9", "name": "rewrite", "sideBar": true}, {"type": "hint", "content": "10", "title": "11"}, {"type": "lemma", "text": "12", "lean": "lemma level1 (x y z w : \u2115) : x + y + (z + w) = (w + z) + (y + x) :=\n", "sideBar": false, "firstProofLineNumber": 184, "lastProofLineNumber": 193, "textBefore": "\n-- use hints --hide\n/-\n## The setup\nWelcome to Lean! You should see a different windows on this page, they will contain part of using Lean,\nlets go through them one-by-one.\n\nThe middle one is where you tell Lean what steps you want to make in your proof.\nBy typing statements here in precise language we instruct Lean how we want the proof to go.\nRight now this text is frozen, but at the bottom you will be able to type your first Lean\nproof.\n\n**Scroll down now and delete the word sorry from the box at the very bottom** this will\nactivate Lean for you so we can introduce the different components.\n**Then scroll back up and carry on reading from here**.\n\nOn the right hand side you can see a window with `goal` at the top.\nThis panel represents what Lean thinks the current state of your proof is, most importantly\nthe facts and hypothesis you already know, and the statement (or statements) you are trying to show, these come after\nthe `\u22a2` symbol to make it clear which is which.\nFor example a valid state might look like\n```\nn : \u2115\nh : is_even n\n\u22a2 is_odd (n + 1)\n```\nwhich means that we have assumed `n` is a natural number and that `n` is even, and we are trying to show that `n + 1` is\nodd.\nIn order to prove this we will need to use more than what is written here however, we might need the definition of\nan even and an odd number, so in addition to the current hypotheses we also will make use of a library of lemmas that\nwe have proved so far.\n\nBelow this there will be more information about the word your cursor is currently on, and feedback about any errors\nin your current proof.\nAs you move your cursor around by clicking different parts of the proof the goal will update, we can\nalways step backwards and forwards through the proof using the arrow keys to check what we were\nproving before.\nIf you write some syntax Lean doesn't understand, or a proof step that doesn't make sense, Lean will\nreturn an error in the bottom right, the most common error being `tactic failed, there are unsolved goals`\nwhich just means that you aren't finished with the proof yet!\n\nOn the left of the screen you will find a list of *theorems* and *tactics* you can use to prove\nresults, this is here to remind you the things we've talked about so far.\n\nLet's now discuss the language Lean uses to represent statements.\n\n## The language\n\nA lemma in Lean is written using a specific syntax, that is designed to look similar to written\nmathematics, but is more restricted in how statements can be constructed.\nHere is an example of a lemma statement in Lean:\n-/\n\nnamespace boop --hide\nlemma add_comm : \u2200 (x : \u2115) (y : \u2115), x + y = y + x\n:= nat.add_comm --hide\n\n/-\nThis lemma states that for all natural numbers `x` and `y` that addition of `x` and `y` commutes,\nhopefully you agree that this is a straightforward, but very useful fact!\nNote the first word `lemma` is a keyword (highlighted in blue) and means we are stating a new\nlemma.\nThe second word is simply a name we give to the lemma so we can refer to it later, naming lemmas\nworks much better than numbering lemmas when you need to refer back to many things.\nThis is especially helpful if you give the lemmas sensible names, so that you can remember them\nlater, and so that when you use them you can tell what the lemma does from its name.\nIn this case `add_comm` says that addition is commutative, so it seems like a pretty good choice.\n\nThe symbol `:` is used to say that `x` and `y` are natural numbers, this is similar to how we\nnormally write `x \u2208 \u2115`, and you should think of `:` as meaning `\u2208`.\nThe symbol `:` is also used after the name of the lemma, and it has the same meaning!\nHere within the lemma `x : \u2115` gives a name to a natural number and\n`add_comm : \u2200 x y, x + y = y + x` gives a name to the statement that addition is commutative.\n\nThe lemma `add_comm` is a \"for all\" statement, so in order to get the statement that addition\ncommutes for a _specific_ pair of natural numbers rather than variables `x` and `y`,\nwe place the naturals we want to refer to after the name,\nfor instance `add_comm 2 3` means `2 + 3 = 3 + 2`.\nHere we used 2 and 3, but we could apply this lemma with variables too by using their names\ninstead of 2 and 3.\n\n\n### Rewriting\nRewriting is one of the most basic methods of proof, we substitute one object we know equals another\ninside what we want to prove, by doing this we can get closer to something that we already know to\nbe true,\nor get to a point where things cancel out or simplify.\n\nFor example if `h` is a name for the fact that `X = Y`, then `rewrite h,` will change\nall `X`s in the goal to `Y`s (the comma at the end is important, it tells Lean you are done\nwith one step of your proof).\nOn the left hand side in the tactics panel there is a dropdown with a lot more details about\n`rewrite`, you don't need to read it now, but it's there if you ever want to check the syntax\nagain.\n\nNow try to use a sequence of `rewrite` steps to prove the lemma below by typing them into the box\nunderneath, between the `begin` and `end` lines that tell Lean you are starting and finishing a\nproof.\n\n-/\n\n/- Tactic : rewrite\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rewrite h,` will change\nall `X`s in the goal to `Y`s.\n\nAs this is such a common proof step we also have a short name, `rw` instead of `rewrite` for this\nstep, to save us from too much typing.\n\nVariants: `rw \u2190 h` (type `\u2190` using `\\l` for left) changes\n`Y` to `X` and\n`rw h at h2` changes `X` to `Y` in hypothesis `h2` instead\nof the goal.\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s.\n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\nImportant note: if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\nPro tip 1: If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l`,\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : set X\nh : A = B \u222a C\n\u22a2 A \u222a B = B \u222a C\n```\n\nthen\n\n`rw h,`\n\nwill change the goal into `\u22a2 B \u222a C \u222a B = B \u222a C`.\n\n### Example:\nYou can use `rw` to change a hypothesis as well.\nFor example, if your local context looks like this:\n```\nA B C D : set X\nh1 : A = B \u2229 C\nh2 : B \u222a A = D\n\u22a2 D = B\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : B \u222a B \u2229 C = D` (remember operator precedence).-/\n\n/- Axiom : The commutativity of addition\nadd_comm : \u2200 x y, x + y = y + x\n-/\n\n\n/- Hint : Click here for a hint, in case you get stuck.\nDelete `sorry` and type `rewrite add_comm x y,` (don't forget the comma!).\nThat is the first step of the proof, after typing the comma you should see the goal (on the right)\nchange so the sides of the equation look closer to each other.\nThe next two steps of the proof go on the next lines, and are similar to the first, can you work\nthem out?\n-/\n\n/- Lemma : no-side-bar\n-/\nlemma level1 (x y z w : \u2115) : x + y + (z + w) = (w + z) + (y + x) :=\nbegin\n", "proof": "  rw add_comm x y,\n  rw add_comm w z,\n  rw add_comm,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\nend boop --hide\n", "height": 10, "editorText": "sorry", "lineOffset": 183, "name": "level1", "statement": "(x y z w : \u2115) : x + y + (z + w) = (w + z) + (y + x)"}, {"type": "lean", "content": "13", "hidden": true}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "14", "hidden": true}, {"type": "text", "content": "15"}, {"type": "axiom", "content": "16", "name": "", "sideBar": true}, {"type": "lean", "content": "17", "hidden": false}, {"type": "lean", "content": "18", "hidden": true}, {"type": "axiom", "content": "19", "name": "", "sideBar": true}, {"type": "lean", "content": "20", "hidden": false}, {"type": "lean", "content": "21", "hidden": true}, {"type": "hint", "content": "22", "title": "23"}, {"type": "lemma", "text": "24", "lean": "lemma level2 (x y : \u2115) (hx : x + 0 = 1 * y) : x + y = y + y :=\n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 51, "textBefore": "import intro.level1 --hide\n/-\nWe can state lemmas assuming hypotheses with similar notation as we made a lemma\ndependent on natural numbers before.\n\nThe `rewrite` tactic can then be used to rewrite a hypothesis, after all we can substitute\nthings we know to be equal in facts we know as well as substituting into what we are trying to prove.\n\n### Example:\nYou can use `rewrite` to change a hypothesis as well.\nFor example, if your goal state looks like this:\n```\nn m : \u2115\nh1 : n + 1 = 7\nh2 : m = n + 1\n\u22a2 m + 2 = 9\n```\nthen `rewrite h2 at h1` will turn `h1` into `h1 : m = 7`.\n\nBelow are two useful results you can use to finish this level.\n-/\n\n/- Axiom :\nlemma add_zero : \u2200 x, x + 0 = x\n-/\nlemma add_zero : \u2200 x, x + 0 = x\n:= nat.add_zero --hide\n/- Axiom :\nlemma one_mul : \u2200 x, 1 * x = x\n-/\nlemma one_mul : \u2200 x, 1 * x = x\n:= nat.one_mul --hide\n\n/- Hint : Click here for a hint, in case you get stuck.\nDelete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\nDelete `sorry` and type `rewrite add_zero x at hx,` (don't forget the comma!), as a first step of the proof.\nIn fact, in this situation the `rewrite` tactic can infer that the argument of `add_zero` should be `x`,\nso one could leave out the argument `x`, i.e. simply write `rewrite add_zero at hx,` (don't forget the comma!).\n-/\n\n/- Lemma : no-side-bar\n-/\nlemma level2 (x y : \u2115) (hx : x + 0 = 1 * y) : x + y = y + y :=\nbegin\n", "proof": "  rw add_zero at hx,\n  rw one_mul at hx,\n  rw hx,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 6, "editorText": "sorry", "lineOffset": 45, "name": "level2", "statement": "(x y : \u2115) (hx : x + 0 = 1 * y) : x + y = y + y"}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "25", "hidden": true}, {"type": "text", "content": "26"}, {"type": "lean", "content": "27", "hidden": true}, {"type": "lean", "content": "28", "hidden": false}, {"type": "lean", "content": "29", "hidden": true}, {"type": "lean", "content": "30", "hidden": true}, {"type": "text", "content": "31"}, {"type": "axiom", "content": "32", "name": "iff_self", "sideBar": true}, {"type": "axiom", "content": "33", "name": "iff_true", "sideBar": true}, {"type": "axiom", "content": "34", "name": "not_not", "sideBar": true}, {"type": "lemma", "text": "35", "lean": "lemma prop_prop (P Q R : Prop) (hPQ : P \u2194 Q) (hQR : Q \u2194 \u00acR) :\n  (\u00acP \u2194 (Q \u2194 P)) \u2194 R :=\n", "sideBar": true, "firstProofLineNumber": 48, "lastProofLineNumber": 56, "textBefore": "import logic.basic --hide\n\n/-\nSo far we've worked with numbers in Lean and seen how we can substitute equalities\nof natural numbers using `rewrite`.\nIn Lean we don't just work with objects like numbers, but we can also manipulate and prove things\nthat are far more abstract, and deal with propositions themselves as objects we want to prove things about.\n\nIn Lean these are called *propositions* and denoted `P : Prop`, exactly the same as how we had `n : \u2115`\nbefore.\nA proposition itself is a statement we might be trying to prove or disprove, but we can use the\nsame tool we used so far, rewriting, to manipulate them.\nWhen dealing with concrete objects like numbers, we substitute equal numbers when proving.\nFor propositions we can subsitute equivalent propositions, where propositions are equivalent\nif they are related by and if and only if. For instance one simple fact is that\n-/\nnamespace bloop --hide\nlemma or_comm : \u2200 (P Q : Prop), P \u2228 Q \u2194 Q \u2228 P\n:= or_comm --hide\nend bloop --hide\n/-\nSo if we wanted to show `\u22a2 x = 2 \u2228 y = 1` we could `rewrite or_comm,` to change the goal to\n`\u22a2 y = 1 \u2228 x = 2`, which might then match one of our hypotheses better.\n\nCheck out the left sidebar for some new lemmas that you can use to prove the statement below.\nOne subtlety, note the curly (instead of round) brackets used in `{P : Prop}` in the `not_not` lemma statement.\nThis signals that `P` is a so-called implicit argument to `not_not`, meaning that syntax like `rewrite not_not P,` is not correct,\nand instead `rewrite not_not,` should be used (where the argument `P` is then infered automatically).\n-/\n\n/- Axiom : iff_self\n\u2200 (P : Prop), (P \u2194 P) \u2194 true\n-/\n\n/- Axiom : iff_true\n\u2200 (P : Prop), (P \u2194 true) \u2194 P\n-/\n\n/- Axiom : not_not\n\u2200 {P : Prop}, \u00ac \u00ac P \u2194 P\n-/\n\n/- Lemma :\n-/\nlemma prop_prop (P Q R : Prop) (hPQ : P \u2194 Q) (hQR : Q \u2194 \u00acR) :\n  (\u00acP \u2194 (Q \u2194 P)) \u2194 R :=\nbegin\n", "proof": "  rw hPQ,\n  rw iff_self,\n  rw iff_true,\n  rw hQR,\n  rw not_not,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 47, "name": "prop_prop", "statement": "(P Q R : Prop) (hPQ : P \u2194 Q) (hQR : Q \u2194 \u00acR) :\n  (\u00acP \u2194 (Q \u2194 P)) \u2194 R"}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "36", "hidden": true}, {"type": "text", "content": "37"}, {"type": "tactic", "content": "38", "name": "exact", "sideBar": true}, {"type": "axiom", "content": "39", "name": "", "sideBar": true}, {"type": "axiom", "content": "40", "name": "", "sideBar": true}, {"type": "axiom", "content": "41", "name": "", "sideBar": true}, {"type": "axiom", "content": "42", "name": "", "sideBar": true}, {"type": "axiom", "content": "43", "name": "", "sideBar": true}, {"type": "axiom", "content": "44", "name": "", "sideBar": true}, {"type": "lemma", "text": "45", "lean": "lemma prop_prop (P Q : Prop) (h : Q \u2227 P \u2227 Q) :\n  (P \u2228 \u00ac Q) \u2227 Q :=\n", "sideBar": false, "firstProofLineNumber": 86, "lastProofLineNumber": 92, "textBefore": "import logic.basic --hide\n\n/-\n## Exact\n\nSometimes after rewriting the hypotheses and goal enough we reach a point where the goal is\nexactly the same as one of the hypothesis.\nIn this case we want to tell Lean that we are finished, one of our hypotheses now matches\nthe conclusion we needed to get to.\n\nThe tactic to do this is called `exact`, and to use it we just need to supply the name of\nthe hypothesis we want to use.\n\nFor example if we were trying to prove that 3 divides some natural number `n` and we\nended up with the goal state:\n```\nn : \u2115\nh : 3 \u2223 n\n\u22a2 3 \u2223 n\n```\nthen `exact h,` would complete the proof.\n\n-/\n\n/- Tactic : exact\n\n## Summary\n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`.\n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this:\n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n-/\n\n/- Axiom :\nor_and_distrib_right : \u2200 {a b c : Prop}, (a \u2228 b) \u2227 c \u2194 a \u2227 c \u2228 b \u2227 c\n-/\n\n/- Axiom :\nnot_and_self (a : Prop) : (\u00aca \u2227 a) \u2194 false\n-/\n\n/- Axiom :\nor_false (a : Prop) : (a \u2228 false) \u2194 a\n-/\n\n/- Axiom :\nand_comm : \u2200 (a b : Prop), a \u2227 b \u2194 b \u2227 a\n-/\n\n/- Axiom :\nand_assoc : \u2200 {c : Prop} (a b : Prop), (a \u2227 b) \u2227 c \u2194 a \u2227 b \u2227 c\n-/\n\n/- Axiom :\nand_self : \u2200 (a : Prop), a \u2227 a \u2194 a\n-/\n\n/- Lemma : no-side-bar\n-/\nlemma prop_prop (P Q : Prop) (h : Q \u2227 P \u2227 Q) :\n  (P \u2228 \u00ac Q) \u2227 Q :=\nbegin\n", "proof": "  rw or_and_distrib_right,\n  rw not_and_self,\n  rw or_false,\n  rw and_comm at h,\n  rw and_assoc at h,\n  rw and_self at h,\n  exact h,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 85, "name": "prop_prop", "statement": "(P Q : Prop) (h : Q \u2227 P \u2227 Q) :\n  (P \u2228 \u00ac Q) \u2227 Q"}]}]}, {"name": "46", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "47", "name": "intro", "sideBar": true}, {"type": "text", "content": "48"}, {"type": "hint", "content": "49", "title": "50"}, {"type": "lean", "content": "51", "hidden": true}, {"type": "lemma", "text": "52", "lean": "lemma example_on_intro (A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B :=\n", "sideBar": false, "firstProofLineNumber": 50, "lastProofLineNumber": 54, "textBefore": "/- Tactic : intro\n\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n-/\n\n/-\nIn this level we introduce the tactic `intro`. You will need it to get started.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nTry something like `intro h1,` and go from there.\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A and B are sets and A = B, then x \u2208 A \u2192 x \u2208 B.\n-/\nlemma example_on_intro (A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B :=\nbegin\n", "proof": "  intro h1,\n  rw \u2190 h,\n  exact h1,\n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 49, "name": "example_on_intro", "statement": "(A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B"}]}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "53", "hidden": true}, {"type": "lean", "content": "54", "hidden": false}, {"type": "tactic", "content": "55", "name": "apply", "sideBar": true}, {"type": "lean", "content": "56", "hidden": true}, {"type": "axiom", "content": "57", "name": "Adding two continuous functions is continuous", "sideBar": true}, {"type": "axiom", "content": "58", "name": "Multiplying two continuous functions is continuous", "sideBar": true}, {"type": "axiom", "content": "59", "name": "", "sideBar": true}, {"type": "axiom", "content": "60", "name": "A constant function is continuous", "sideBar": true}, {"type": "axiom", "content": "61", "name": "The identity function is continuous", "sideBar": true}, {"type": "lemma", "text": "62", "lean": "lemma poly_continuous : continuous (\u03bb x : \u211d, 5 * x ^ 2 + x + 6) :=\n", "sideBar": false, "firstProofLineNumber": 75, "lastProofLineNumber": 85, "textBefore": "import topology.continuous_function.polynomial -- hide\n\n/- # Using apply\nIn this problem you will show that a specific polynomial is continuous, you can do this using\nthe basic facts in the left sidebar: that adding continuous functions is continuous,\nlikewise multiplying continuous functions remains continuous, constant functions are continuous,\nand the identity function is continuous. The way these lemmas are stated is very general, they work\nfor any continuous functions on arbitrary topological spaces, but by using `apply` we can let Lean\nwork out the details automatically.\n\nBut how do we talk about the functions themselves?\nThe basic method to speak about an unnamed function in Lean makes use of the lambda syntax.\nIn mathematics we might just write $x ^ 3 + 7$ to describe a polynomial function, leaving it\nimplicit that $x$ is the variable.\nIn Lean we use the symbol \u03bb (`\\lambda`) to describe a function by placing the name of the variable\nafter the lambda.\nSo `\u03bb x, x^3 + 7` defines the function which takes input `x` and outputs `x^3 + 7` in Lean.\n\nWatch out! Some of these lemmas have names with a dot like `continuous.add` (these ones\nprove continuity of a combination of functions) and some have an underscore like\n`continuous_const` (these ones state that some specific function is continuous).\n\n-/\n\n/- Tactic : apply\n\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`.\n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n-/\n\nopen polynomial-- hide\n/- Axiom : Adding two continuous functions is continuous\ncontinuous.add : \u2200 {X M : Type} [topological_space X] [topological_space M] [has_add M]\n  [has_continuous_add M] {f g : X \u2192 M},\n  continuous f \u2192 continuous g \u2192 continuous (\u03bb (x : X), f x + g x)\n-/\n/- Axiom : Multiplying two continuous functions is continuous\ncontinuous.mul : \u2200 {X M : Type} [topological_space X] [ topological_space M]\n  [has_mul M] [has_continuous_mul M] {f g : X \u2192 M},\n  continuous f \u2192 continuous g \u2192 continuous (\u03bb (x : X), f x * g x)\n-/\n/- Axiom :\ncontinuous.pow : \u2200 {X M : Type} [topological_space X] [topological_space M] [monoid M]\n  [has_continuous_mul M] {f : X \u2192 M},\n  continuous f \u2192 \u2200 (n : \u2115), continuous (\u03bb (b : X), f b ^ n)\n-/\n/- Axiom : A constant function is continuous\ncontinuous_const : \u2200 {\u03b1 \u03b2 : Type} [topological_space \u03b1] [topological_space \u03b2] {b : \u03b2},\n  continuous (\u03bb (a : \u03b1), b)\n-/\n/- Axiom : The identity function is continuous\ncontinuous_id : \u2200 {\u03b1 : Type} [topological_space \u03b1], continuous (\u03bb x, x)\n-/\n\n/- Lemma : no-side-bar\n-/\nlemma poly_continuous : continuous (\u03bb x : \u211d, 5 * x ^ 2 + x + 6) :=\nbegin\n", "proof": "  apply continuous.add,\n  apply continuous.add,\n  apply continuous.mul,\n  apply continuous_const,\n  apply continuous.pow,\n  apply continuous_id,\n  apply continuous_id,\n  apply continuous_const,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 11, "editorText": "sorry", "lineOffset": 74, "name": "poly_continuous", "statement": "continuous (\u03bb x : \u211d, 5 * x ^ 2 + x + 6)"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "63", "hidden": false}, {"type": "tactic", "content": "64", "name": "split", "sideBar": true}, {"type": "axiom", "content": "65", "name": "nat.lt_succ_self : \u2200 (n : \u2115), n < n.succ", "sideBar": true}, {"type": "lemma", "text": "66", "lean": "lemma split : 4 < 5 \u2227 5 < 6 :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 16, "textBefore": "import tactic\n\n/- Tactic : split\nWhen given a goal that is an `\u2227` (and) of two propositions, the `split` tactic\nwill produce two goals, one for each side. That can be solved individually.\n-/\n\n/- Axiom : nat.lt_succ_self : \u2200 (n : \u2115), n < n.succ\n-/\n/- Lemma :\n-/\nlemma split : 4 < 5 \u2227 5 < 6 :=\nbegin\n", "proof": "  split,\n  exact nat.lt_succ_self 4,\n  exact nat.lt_succ_self 5,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 13, "name": "split", "statement": "4 < 5 \u2227 5 < 6"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "67", "hidden": false}, {"type": "tactic", "content": "68", "name": "use", "sideBar": true}, {"type": "lemma", "text": "69", "lean": "lemma exists_betwn : \u2203 n : \u2115, 8 < n \u2227 n < 10 :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 28, "textBefore": "import inter.level3\nimport tactic\n\n/- Tactic : use\nWhen the goal is to prove an existential, `\u2203` we can\nsupply the witness (an example that has the desired property)\nusing the tactic `use`.\n\nFor example :\nIf the goal is\n```\n\u22a2 \u2203 n : \u2115, n + 1 = 1\n```\nthen we have to take `n` to be zero, so we type `use 0`.\nThe remaining goal will then be that\n`0 + 1 = 1`\nwhich is provable with `zero_add`.\n-/\n\n\n/- Lemma :\n-/\nlemma exists_betwn : \u2203 n : \u2115, 8 < n \u2227 n < 10 :=\nbegin\n", "proof": "  use 9,\n  split,\n  exact nat.lt_succ_self 8,\n  exact nat.lt_succ_self 9,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 24, "name": "exists_betwn", "statement": "\u2203 n : \u2115, 8 < n \u2227 n < 10"}]}, {"name": "", "problemIndex": 15, "objects": [{"type": "lean", "content": "70", "hidden": false}, {"type": "tactic", "content": "71", "name": "simp", "sideBar": true}, {"type": "text", "content": "72"}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": false}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": false}, {"type": "lean", "content": "77", "hidden": true}, {"type": "axiom", "content": "78", "name": "The definition of commutator", "sideBar": true}, {"type": "lean", "content": "79", "hidden": false}, {"type": "axiom", "content": "80", "name": "The definition of conjugate", "sideBar": true}, {"type": "lean", "content": "81", "hidden": false}, {"type": "axiom", "content": "82", "name": "cancelling inverses on the right", "sideBar": true}, {"type": "axiom", "content": "83", "name": "cancelling an element with its own inverse", "sideBar": true}, {"type": "text", "content": "84"}, {"type": "lemma", "text": "85", "lean": "@[simp]\nlemma commutator_self {G : Type} [group G] {x : G} : [x, x] = 1 :=\n", "sideBar": true, "firstProofLineNumber": 88, "lastProofLineNumber": 94, "textBefore": "import algebra.group.basic\nimport data.bracket\n\n/- # The simplifier\nUp till now we have been using `rewrite` to manually instruct Lean which steps to take one at a time.\nThis is a very useful tool, but after a while you will notice that there are some rewrites that\nwill always make things easier when substituted.\nFor example we almost always want to use the fact that multiplying by 1 or adding 0 doesn't\nchange things.\n-/\n\n/- Tactic : simp\n\n## Summary\n\nThe `simp` tactic is a high-level tactic which tries\nto prove equalities using facts in its database.\n\n## Details\n\nThe `simp` tactic does basic automation.\nFor example, some proofs involve a tedious number of rewrites of `add_assoc` and `add_comm`, \nthe same is true of `mul_assoc` and `mul_comm` in the case of multiplication. \nWe can use `simp` to do this automatically. \nTo tell `simp` to use some lemma `h` when simplifying, write `simp[h]`. More generally, \nfor `simp` to include additional lemmas `h1`, `h2`, ..., `hn` when simplifying, write \n`simp[h1, h2, ..., hn]`. \n\n### Example:\nIf our goal is this:\n```\n\u22a2 a + b + c + d + e = a + (b + (c + d) + e)\n```\n\nwe can solve this with `simp` using `simp[add_assoc]`. \n\n### Example:\nIf our goal is this:\n```\n\u22a2 a * b * c = c * b * a\n```\n-/\n/-\n\n\n# Commutator identities\n\nIn these exercises we will write the proofs of the identities in\n<https://en.wikipedia.org/wiki/Commutator#Identities_(group_theory)>\nin Lean.\n\nFirst we will set up the basic definitions, in World 1, we didn't make any new mathematical\ndefinitions, we just made use of the natural numbers, propositions, and some lemmas Lean\nalready knew about.\n\n-/\nnotation `[`x`, `y`]` := has_bracket.bracket x y -- hide\ndefinition commutator {G : Type*} [group G] (x y : G) : G := x\u207b\u00b9 * y\u207b\u00b9 * x * y\ninstance group.has_bracket {G : Type*} [group G] : has_bracket G G := \u27e8commutator\u27e9 -- hide\ndefinition conjugate {G : Type*} [group G] (x y : G) : G := y\u207b\u00b9 * x * y\ninstance group.has_pow {G : Type*} [group G] : has_pow G G := \u27e8conjugate\u27e9 -- hide\n/- Axiom : The definition of commutator\ncommutator_def : [x, y] = x\u207b\u00b9 * y\u207b\u00b9 * x * y\n-/\nlemma commutator_def {G : Type*} [group G] {x y : G} : [x, y] = x\u207b\u00b9 * y\u207b\u00b9 * x * y := rfl\n/- Axiom : The definition of conjugate\nconjugate_def : y^x = x\u207b\u00b9 * y * x := rfl\n-/\nlemma conjugate_def {G : Type*} [group G] {x y : G} : y^x = x\u207b\u00b9 * y * x := rfl\n\n/- Axiom : cancelling inverses on the right\ninv_mul_cancel_right : \u2200 {G : Type} [_inst_1 : group G] (a b : G), a * b\u207b\u00b9 * b = a\n-/\n\n/- Axiom : cancelling an element with its own inverse\ninv_mul_self : \u2200 {G : Type} [_inst_1 : group G] (a : G), a\u207b\u00b9 * a = 1\n-/\n\n/-\nRemember to check out the panel on the left for some useful lemmas\n-/\n\n/- Lemma :\n-/\n@[simp]\nlemma commutator_self {G : Type} [group G] {x : G} : [x, x] = 1 :=\nbegin\n", "proof": "  rw commutator_def,\n  rw inv_mul_cancel_right,\n  rw inv_mul_self,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 87, "name": "lemma", "statement": "commutator_self {G : Type} [group G] {x : G} : [x, x] = 1"}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "86", "hidden": false}, {"type": "text", "content": "87"}, {"type": "lean", "content": "88", "hidden": true}, {"type": "lean", "content": "89", "hidden": false}, {"type": "lean", "content": "90", "hidden": true}, {"type": "lean", "content": "91", "hidden": false}, {"type": "lean", "content": "92", "hidden": true}, {"type": "lean", "content": "93", "hidden": true}, {"type": "lemma", "text": "94", "lean": "lemma conjugate_self {G : Type*} [group G] {x : G} : x ^ x = x :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 23, "textBefore": "import simplifier.level_commutator_1\n\n/-\nHow far will simp get you here?\n-/\nnamespace bloop--hide\n@[simp]\nlemma inv_mul_self {G : Type} [group G] (a : G) : a\u207b\u00b9 * a = 1\n:= mul_left_inv a --hide\n@[simp]\nlemma one_mul {G : Type} [group G] (a : G) : 1 * a = a\n:= one_mul _ --hide\n\nend bloop--hide\n\n/- Lemma :\n-/\nlemma conjugate_self {G : Type*} [group G] {x : G} : x ^ x = x :=\nbegin\n", "proof": "  rw [conjugate_def, inv_mul_self, one_mul],\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 19, "name": "conjugate_self", "statement": "{G : Type*} [group G] {x : G} : x ^ x = x"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "95", "hidden": false}, {"type": "text", "content": "96"}, {"type": "lemma", "text": "97", "lean": "lemma commutator_inv {G : Type*} [group G] {x y : G} : [y, x] = [x, y]\u207b\u00b9 :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 29, "textBefore": "import simplifier.level_commutator_2\n\n/-\nHere you might want to use `simp` together with the fact that multiplication is associative \n(this lemma is called `mul_assoc` as you might have guessed). Recall that you can tell \n`simp` to use lemma `h` when simplifying by writing `simp[h]`.  \n-/\n\n/- Lemma :\n-/\nlemma commutator_inv {G : Type*} [group G] {x y : G} : [y, x] = [x, y]\u207b\u00b9 :=\nbegin\n", "proof": "  rw [commutator_def, commutator_def, mul_inv_rev, mul_inv_rev, mul_inv_rev, inv_inv, inv_inv,\n    mul_assoc, mul_assoc],\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 17, "editorText": "sorry", "lineOffset": 12, "name": "commutator_inv", "statement": "{G : Type*} [group G] {x y : G} : [y, x] = [x, y]\u207b\u00b9"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "98", "hidden": false}, {"type": "lemma", "text": "99", "lean": "lemma commutator_mul {G : Type*} [group G] {x y z : G} : [x, z * y] = [x, y] * [x, z]^y :=\n", "sideBar": true, "firstProofLineNumber": 7, "lastProofLineNumber": 21, "textBefore": "import simplifier.level_commutator_3\n\n/- Lemma :\n-/\nlemma commutator_mul {G : Type*} [group G] {x y z : G} : [x, z * y] = [x, y] * [x, z]^y :=\nbegin\n", "proof": "  rw [commutator_def, commutator_def, commutator_def, conjugate_def, mul_inv_rev],\n  assoc_rw [mul_inv_self],\n  rw mul_one,\n  assoc_rw [mul_inv_self],\n  rw mul_one,\n  simp [mul_assoc],\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 15, "editorText": "sorry", "lineOffset": 6, "name": "commutator_mul", "statement": "{G : Type*} [group G] {x y z : G} : [x, z * y] = [x, y] * [x, z]^y"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "lean", "content": "100", "hidden": false}, {"type": "lemma", "text": "101", "lean": "lemma hall_witt {G : Type*} [group G] {x y z : G} :\n  [[x, y\u207b\u00b9], z] ^ y * [[y, z\u207b\u00b9], x] ^ z * [[z, x\u207b\u00b9], y] ^ x = 1 :=\n", "sideBar": true, "firstProofLineNumber": 8, "lastProofLineNumber": 72, "textBefore": "import simplifier.level_commutator_4\n\n/- Lemma :\n-/\nlemma hall_witt {G : Type*} [group G] {x y z : G} :\n  [[x, y\u207b\u00b9], z] ^ y * [[y, z\u207b\u00b9], x] ^ z * [[z, x\u207b\u00b9], y] ^ x = 1 :=\nbegin\n", "proof": "  rw commutator_def,\n  rw commutator_def,\n  rw commutator_def,\n  rw commutator_def,\n  rw commutator_def,\n  rw commutator_def,\n  rw inv_inv,\n  rw inv_inv,\n  rw inv_inv,\n  rw conjugate_def,\n  rw conjugate_def,\n  rw conjugate_def,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw mul_inv_rev,\n  rw inv_inv,\n  rw inv_inv,\n  rw inv_inv,\n  assoc_rw [inv_mul_self],\n  assoc_rw [inv_mul_self],\n  assoc_rw [inv_mul_self],\n  rw one_mul,\n  rw mul_one,\n  rw mul_one,\n  rw mul_inv_cancel_right,\n  rw mul_inv_cancel_right,\n  rw mul_inv_cancel_right,\n  rw mul_inv_cancel_right,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw mul_assoc,\n  rw inv_mul_cancel_left,\n  rw mul_inv_cancel_left,\n  rw inv_mul_cancel_left,\n  rw mul_inv_cancel_left,\n  rw mul_inv_cancel_left,\n  rw mul_inv_cancel_left,\n  rw inv_mul_cancel_left,\n  rw inv_mul_cancel_left,\n  rw mul_inv_cancel_left,\n  rw inv_mul_cancel_left,\n  rw inv_mul_self,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 65, "editorText": "sorry", "lineOffset": 7, "name": "hall_witt", "statement": "{G : Type*} [group G] {x y z : G} :\n  [[x, y\u207b\u00b9], z] ^ y * [[y, z\u207b\u00b9], x] ^ z * [[z, x\u207b\u00b9], y] ^ x = 1"}]}], "parents": [0]}, {"name": "102", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "103", "hidden": false}, {"type": "text", "content": "104"}, {"type": "axiom", "content": "105", "name": "continuous_def : \u2200 {\u03b1 : Type} {\u03b2 : Type} [topological_space \u03b1]", "sideBar": true}, {"type": "axiom", "content": "106", "name": "set.preimage_comp : \u2200 {\u03b1 \u03b2 \u03b3 : Type} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s : set \u03b3},", "sideBar": true}, {"type": "text", "content": "107"}, {"type": "lemma", "text": "108", "lean": "lemma image_compact\n  (X Y Z : Type)\n  [topological_space X]\n  [topological_space Y]\n  [topological_space Z]\n  (f : X \u2192 Y)\n  (g : Y \u2192 Z)\n  (hf : continuous f)\n  (hg : continuous g) :\n  continuous (g \u2218 f) :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 40, "textBefore": "import topology.basic\n\n/-\nIn this problem you will look at proving that the composition of two continuous maps is\ncontinuous\n\nSome things you should know:\n- A subset of a space `X` is an element of the type `set X` in Lean\n- The notation for the preimage of a set `U` along a map `f` is `f \u207b\u00b9' U`\n-/\n/- Axiom : continuous_def : \u2200 {\u03b1 : Type} {\u03b2 : Type} [topological_space \u03b1]\n  [topological_space \u03b2] {f : \u03b1 \u2192 \u03b2},\n  continuous f \u2194 \u2200 (s : set \u03b2),is_open s \u2192 is_open (f \u207b\u00b9' s)\n-/\n/- Axiom : set.preimage_comp : \u2200 {\u03b1 \u03b2 \u03b3 : Type} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s : set \u03b3},\ng \u2218 f \u207b\u00b9' s = f \u207b\u00b9' (g \u207b\u00b9' s)\n-/\n/-\nYou will need to use the tactics intros, rewrite, and apply for this problem!\nAnd some new lemmas that are in the sidebar for you.\n-/\n/- Lemma :\n-/\nlemma image_compact\n  (X Y Z : Type)\n  [topological_space X]\n  [topological_space Y]\n  [topological_space Z]\n  (f : X \u2192 Y)\n  (g : Y \u2192 Z)\n  (hf : continuous f)\n  (hg : continuous g) :\n  continuous (g \u2218 f) :=\nbegin\n", "proof": "  rw continuous_def at *,\n  intros S hS,\n  rw [set.preimage_comp],\n  apply hf,\n  apply hg,\n  apply hS,", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 6, "editorText": "sorry", "lineOffset": 34, "name": "image_compact", "statement": "(X Y Z : Type)\n  [topological_space X]\n  [topological_space Y]\n  [topological_space Z]\n  (f : X \u2192 Y)\n  (g : Y \u2192 Z)\n  (hf : continuous f)\n  (hg : continuous g) :\n  continuous (g \u2218 f)"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "109", "hidden": false}, {"type": "text", "content": "110"}, {"type": "hint", "content": "111", "title": "112"}, {"type": "axiom", "content": "113", "name": "continuous.is_open_preimage : \u2200 {\u03b1 \u03b2 : Type} [_inst_1 : topological_space \u03b1]", "sideBar": true}, {"type": "lemma", "text": "114", "lean": "lemma image_compact\n  (X : Type)\n  [topological_space X]\n  (V : set X)\n  (h : is_compact V)\n  (Y : Type)\n  [topological_space Y]\n  (f : X \u2192 Y)\n  (hf : continuous f) :\n  is_compact (f '' V) :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 50, "textBefore": "import topology.subset_properties\n\n/-\nIn this problem you will look at proving that the image of a compact set in a topological space\nalong a continuous map is also compact.\n\nSome things you should know:\n- A subset of a space `X` is an element of the type `set X` in Lean\n- The notation for image of a set `U` along a map `f` is `f '' U`\n- The simplifier `simp,`,\n  is very useful, especially simplifying your hypotheses  `simp at ht` !\n  You can use `simp at *,` to simplify as much as possible everywhere\n- there is a new helpful lemma in the sidebar\n-/\n/- Hint : click here for the first few lines of the proof\n```\nrw is_compact_iff_finite_subcover, -- rewrite the definition of compactness\nrw is_compact_iff_finite_subcover at h,  -- rewrite the definition of compactness\nintros \u03b9 V hV hVu, -- we are proving a forall, so introduce everything\nobtain \u27e8t, ht\u27e9 := h (\u03bb i, f \u207b\u00b9' (V i)) _ _, -- pull back the open sets from Y to X\n```\n-/\n/- Axiom : continuous.is_open_preimage : \u2200 {\u03b1 \u03b2 : Type} [_inst_1 : topological_space \u03b1]\n  [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2},\n  continuous f \u2192 \u2200 (s : set \u03b2), is_open s \u2192 is_open (f \u207b\u00b9' s)\n-/\n/- Lemma :\n-/\nlemma image_compact\n  (X : Type)\n  [topological_space X]\n  (V : set X)\n  (h : is_compact V)\n  (Y : Type)\n  [topological_space Y]\n  (f : X \u2192 Y)\n  (hf : continuous f) :\n  is_compact (f '' V) :=\nbegin\n", "proof": "  rw is_compact_iff_finite_subcover,\n  rw is_compact_iff_finite_subcover at h,\n  intros \u03b9 V hV hVu,\n  obtain \u27e8t, ht\u27e9 := h (\u03bb i, f \u207b\u00b9' (V i)) _ _,\n  use t,\n  simp [ht],\n  intro i,\n  simp,\n  apply continuous.is_open_preimage hf (V i) (hV i),\n  simp at hVu,\n  simp [hVu],", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 11, "editorText": "sorry", "lineOffset": 39, "name": "image_compact", "statement": "(X : Type)\n  [topological_space X]\n  (V : set X)\n  (h : is_compact V)\n  (Y : Type)\n  [topological_space Y]\n  (f : X \u2192 Y)\n  (hf : continuous f) :\n  is_compact (f '' V)"}]}], "parents": [1]}], "texts": [["Lean CAP game", "# The CAP Game, version 1.0.0.\n\nLearn to use computers to formalize proofs!\n\n# What is this game?\n\nIn this game, you will learn the basics of how a program called a *proof assistant* works and use\nit to formalize some mathematical results.\nWhat does this mean? Instead of writing down proofs in English or any other human language we will\nexplain the steps of the proof to the proof assistant using a precise language, similar to a\nprogramming language in some aspects.\nThe advantage of doing this is that the computer can then keep track of the proof for us, and tell\nus if we make any steps that aren't logically valid, computers are very good at understanding logic\nafter all!\nOther than needing to use specific commands to explain the proof steps, we can work on proofs like\nusual, using definitions and already established facts to show new results.\nThe proof assistant will completely keep track of what facts we know so far, and show us what else\nneeds to be shown to finish the current proof, importantly it won't let us show something that\ndoesn't logically follow from what we have proved so far.\n\nThis is a very literal sort of computer assisted proof, we are using a computer to step through and\nunderstand individual steps in a proof.\nLater we will see how the assistant can do more than just follow our instructions, it can also\nsearch for us and find useful facts we might want to use. Lean can even complete some moderately\ndifficult tricky on its own, using proof methods based on pre-defined rules.\nThis saves us time thinking about details in some situations, without losing any confidence in the\ncorrectness of the result, and in some cases we can even learn from the proofs Lean finds!\n\n\nTo get started click on the first world, the blue circle labelled Intro, on the right.\nYou can use this menu to navigate as you try more of the problems.\nHave fun!\n\nIf you experience any technical issues with the game please let us know on the canvas page.\n\n# Credits\n\nThe CAP Game, was created as part of the course computer assisted proofs at the Vrije Universiteit Amsterdam\n\nBased on templates from Imperial College London and Universitat Aut\u00f2noma de Barcelona.\n\nLean is a proof assistant being developed at Microsoft Research.\n", "Intro", "-- use hints --hide\n", "## The setup\nWelcome to Lean! You should see a different windows on this page, they will contain part of using Lean,\nlets go through them one-by-one.\n\nThe middle one is where you tell Lean what steps you want to make in your proof.\nBy typing statements here in precise language we instruct Lean how we want the proof to go.\nRight now this text is frozen, but at the bottom you will be able to type your first Lean\nproof.\n\n**Scroll down now and delete the word sorry from the box at the very bottom** this will\nactivate Lean for you so we can introduce the different components.\n**Then scroll back up and carry on reading from here**.\n\nOn the right hand side you can see a window with `goal` at the top.\nThis panel represents what Lean thinks the current state of your proof is, most importantly\nthe facts and hypothesis you already know, and the statement (or statements) you are trying to show, these come after\nthe `\u22a2` symbol to make it clear which is which.\nFor example a valid state might look like\n```\nn : \u2115\nh : is_even n\n\u22a2 is_odd (n + 1)\n```\nwhich means that we have assumed `n` is a natural number and that `n` is even, and we are trying to show that `n + 1` is\nodd.\nIn order to prove this we will need to use more than what is written here however, we might need the definition of\nan even and an odd number, so in addition to the current hypotheses we also will make use of a library of lemmas that\nwe have proved so far.\n\nBelow this there will be more information about the word your cursor is currently on, and feedback about any errors\nin your current proof.\nAs you move your cursor around by clicking different parts of the proof the goal will update, we can\nalways step backwards and forwards through the proof using the arrow keys to check what we were\nproving before.\nIf you write some syntax Lean doesn't understand, or a proof step that doesn't make sense, Lean will\nreturn an error in the bottom right, the most common error being `tactic failed, there are unsolved goals`\nwhich just means that you aren't finished with the proof yet!\n\nOn the left of the screen you will find a list of *theorems* and *tactics* you can use to prove\nresults, this is here to remind you the things we've talked about so far.\n\nLet's now discuss the language Lean uses to represent statements.\n\n## The language\n\nA lemma in Lean is written using a specific syntax, that is designed to look similar to written\nmathematics, but is more restricted in how statements can be constructed.\nHere is an example of a lemma statement in Lean:\n", "namespace boop --hide\n", "lemma add_comm : \u2200 (x : \u2115) (y : \u2115), x + y = y + x\n", ":= nat.add_comm --hide\n", "This lemma states that for all natural numbers `x` and `y` that addition of `x` and `y` commutes,\nhopefully you agree that this is a straightforward, but very useful fact!\nNote the first word `lemma` is a keyword (highlighted in blue) and means we are stating a new\nlemma.\nThe second word is simply a name we give to the lemma so we can refer to it later, naming lemmas\nworks much better than numbering lemmas when you need to refer back to many things.\nThis is especially helpful if you give the lemmas sensible names, so that you can remember them\nlater, and so that when you use them you can tell what the lemma does from its name.\nIn this case `add_comm` says that addition is commutative, so it seems like a pretty good choice.\n\nThe symbol `:` is used to say that `x` and `y` are natural numbers, this is similar to how we\nnormally write `x \u2208 \u2115`, and you should think of `:` as meaning `\u2208`.\nThe symbol `:` is also used after the name of the lemma, and it has the same meaning!\nHere within the lemma `x : \u2115` gives a name to a natural number and\n`add_comm : \u2200 x y, x + y = y + x` gives a name to the statement that addition is commutative.\n\nThe lemma `add_comm` is a \"for all\" statement, so in order to get the statement that addition\ncommutes for a _specific_ pair of natural numbers rather than variables `x` and `y`,\nwe place the naturals we want to refer to after the name,\nfor instance `add_comm 2 3` means `2 + 3 = 3 + 2`.\nHere we used 2 and 3, but we could apply this lemma with variables too by using their names\ninstead of 2 and 3.\n\n\n### Rewriting\nRewriting is one of the most basic methods of proof, we substitute one object we know equals another\ninside what we want to prove, by doing this we can get closer to something that we already know to\nbe true,\nor get to a point where things cancel out or simplify.\n\nFor example if `h` is a name for the fact that `X = Y`, then `rewrite h,` will change\nall `X`s in the goal to `Y`s (the comma at the end is important, it tells Lean you are done\nwith one step of your proof).\nOn the left hand side in the tactics panel there is a dropdown with a lot more details about\n`rewrite`, you don't need to read it now, but it's there if you ever want to check the syntax\nagain.\n\nNow try to use a sequence of `rewrite` steps to prove the lemma below by typing them into the box\nunderneath, between the `begin` and `end` lines that tell Lean you are starting and finishing a\nproof.\n\n", "## Summary\n\nIf `h` is a proof of `X = Y`, then `rewrite h,` will change\nall `X`s in the goal to `Y`s.\n\nAs this is such a common proof step we also have a short name, `rw` instead of `rewrite` for this\nstep, to save us from too much typing.\n\nVariants: `rw \u2190 h` (type `\u2190` using `\\l` for left) changes\n`Y` to `X` and\n`rw h at h2` changes `X` to `Y` in hypothesis `h2` instead\nof the goal.\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s.\n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\nImportant note: if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\nPro tip 1: If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l`,\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : set X\nh : A = B \u222a C\n\u22a2 A \u222a B = B \u222a C\n```\n\nthen\n\n`rw h,`\n\nwill change the goal into `\u22a2 B \u222a C \u222a B = B \u222a C`.\n\n### Example:\nYou can use `rw` to change a hypothesis as well.\nFor example, if your local context looks like this:\n```\nA B C D : set X\nh1 : A = B \u2229 C\nh2 : B \u222a A = D\n\u22a2 D = B\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : B \u222a B \u2229 C = D` (remember operator precedence).-/\n\n/- Axiom : The commutativity of addition\nadd_comm : \u2200 x y, x + y = y + x\n", "Delete `sorry` and type `rewrite add_comm x y,` (don't forget the comma!).\nThat is the first step of the proof, after typing the comma you should see the goal (on the right)\nchange so the sides of the equation look closer to each other.\nThe next two steps of the proof go on the next lines, and are similar to the first, can you work\nthem out?\n", "Click here for a hint, in case you get stuck.", "", "end boop --hide\n", "import intro.level1 --hide\n", "We can state lemmas assuming hypotheses with similar notation as we made a lemma\ndependent on natural numbers before.\n\nThe `rewrite` tactic can then be used to rewrite a hypothesis, after all we can substitute\nthings we know to be equal in facts we know as well as substituting into what we are trying to prove.\n\n### Example:\nYou can use `rewrite` to change a hypothesis as well.\nFor example, if your goal state looks like this:\n```\nn m : \u2115\nh1 : n + 1 = 7\nh2 : m = n + 1\n\u22a2 m + 2 = 9\n```\nthen `rewrite h2 at h1` will turn `h1` into `h1 : m = 7`.\n\nBelow are two useful results you can use to finish this level.\n", "lemma add_zero : \u2200 x, x + 0 = x\n", "lemma add_zero : \u2200 x, x + 0 = x\n", ":= nat.add_zero --hide\n", "lemma one_mul : \u2200 x, 1 * x = x\n", "lemma one_mul : \u2200 x, 1 * x = x\n", ":= nat.one_mul --hide\n", "Delete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\nDelete `sorry` and type `rewrite add_zero x at hx,` (don't forget the comma!), as a first step of the proof.\nIn fact, in this situation the `rewrite` tactic can infer that the argument of `add_zero` should be `x`,\nso one could leave out the argument `x`, i.e. simply write `rewrite add_zero at hx,` (don't forget the comma!).\n", "Click here for a hint, in case you get stuck.", "", "import logic.basic --hide\n", "So far we've worked with numbers in Lean and seen how we can substitute equalities\nof natural numbers using `rewrite`.\nIn Lean we don't just work with objects like numbers, but we can also manipulate and prove things\nthat are far more abstract, and deal with propositions themselves as objects we want to prove things about.\n\nIn Lean these are called *propositions* and denoted `P : Prop`, exactly the same as how we had `n : \u2115`\nbefore.\nA proposition itself is a statement we might be trying to prove or disprove, but we can use the\nsame tool we used so far, rewriting, to manipulate them.\nWhen dealing with concrete objects like numbers, we substitute equal numbers when proving.\nFor propositions we can subsitute equivalent propositions, where propositions are equivalent\nif they are related by and if and only if. For instance one simple fact is that\n", "namespace bloop --hide\n", "lemma or_comm : \u2200 (P Q : Prop), P \u2228 Q \u2194 Q \u2228 P\n", ":= or_comm --hide\n", "end bloop --hide\n", "So if we wanted to show `\u22a2 x = 2 \u2228 y = 1` we could `rewrite or_comm,` to change the goal to\n`\u22a2 y = 1 \u2228 x = 2`, which might then match one of our hypotheses better.\n\nCheck out the left sidebar for some new lemmas that you can use to prove the statement below.\nOne subtlety, note the curly (instead of round) brackets used in `{P : Prop}` in the `not_not` lemma statement.\nThis signals that `P` is a so-called implicit argument to `not_not`, meaning that syntax like `rewrite not_not P,` is not correct,\nand instead `rewrite not_not,` should be used (where the argument `P` is then infered automatically).\n", "\u2200 (P : Prop), (P \u2194 P) \u2194 true\n", "\u2200 (P : Prop), (P \u2194 true) \u2194 P\n", "\u2200 {P : Prop}, \u00ac \u00ac P \u2194 P\n", "", "import logic.basic --hide\n", "## Exact\n\nSometimes after rewriting the hypotheses and goal enough we reach a point where the goal is\nexactly the same as one of the hypothesis.\nIn this case we want to tell Lean that we are finished, one of our hypotheses now matches\nthe conclusion we needed to get to.\n\nThe tactic to do this is called `exact`, and to use it we just need to supply the name of\nthe hypothesis we want to use.\n\nFor example if we were trying to prove that 3 divides some natural number `n` and we\nended up with the goal state:\n```\nn : \u2115\nh : 3 \u2223 n\n\u22a2 3 \u2223 n\n```\nthen `exact h,` would complete the proof.\n\n", "\n## Summary\n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`.\n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this:\n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n", "or_and_distrib_right : \u2200 {a b c : Prop}, (a \u2228 b) \u2227 c \u2194 a \u2227 c \u2228 b \u2227 c\n", "not_and_self (a : Prop) : (\u00aca \u2227 a) \u2194 false\n", "or_false (a : Prop) : (a \u2228 false) \u2194 a\n", "and_comm : \u2200 (a b : Prop), a \u2227 b \u2194 b \u2227 a\n", "and_assoc : \u2200 {c : Prop} (a b : Prop), (a \u2227 b) \u2227 c \u2194 a \u2227 b \u2227 c\n", "and_self : \u2200 (a : Prop), a \u2227 a \u2194 a\n", "", "Intermediate", "\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n", "In this level we introduce the tactic `intro`. You will need it to get started.\n", "Try something like `intro h1,` and go from there.\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A and B are sets and A = B, then x \u2208 A \u2192 x \u2208 B.\n", "import topology.continuous_function.polynomial -- hide\n", "/- # Using apply\nIn this problem you will show that a specific polynomial is continuous, you can do this using\nthe basic facts in the left sidebar: that adding continuous functions is continuous,\nlikewise multiplying continuous functions remains continuous, constant functions are continuous,\nand the identity function is continuous. The way these lemmas are stated is very general, they work\nfor any continuous functions on arbitrary topological spaces, but by using `apply` we can let Lean\nwork out the details automatically.\nBut how do we talk about the functions themselves?\nThe basic method to speak about an unnamed function in Lean makes use of the lambda syntax.\nIn mathematics we might just write $x ^ 3 + 7$ to describe a polynomial function, leaving it\nimplicit that $x$ is the variable.\nIn Lean we use the symbol \u03bb (`\\lambda`) to describe a function by placing the name of the variable\nafter the lambda.\nSo `\u03bb x, x^3 + 7` defines the function which takes input `x` and outputs `x^3 + 7` in Lean.\nWatch out! Some of these lemmas have names with a dot like `continuous.add` (these ones\nprove continuity of a combination of functions) and some have an underscore like\n`continuous_const` (these ones state that some specific function is continuous).\n-/\n", "\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`.\n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n", "open polynomial-- hide\n", "continuous.add : \u2200 {X M : Type} [topological_space X] [topological_space M] [has_add M]\n  [has_continuous_add M] {f g : X \u2192 M},\n  continuous f \u2192 continuous g \u2192 continuous (\u03bb (x : X), f x + g x)\n", "continuous.mul : \u2200 {X M : Type} [topological_space X] [ topological_space M]\n  [has_mul M] [has_continuous_mul M] {f g : X \u2192 M},\n  continuous f \u2192 continuous g \u2192 continuous (\u03bb (x : X), f x * g x)\n", "continuous.pow : \u2200 {X M : Type} [topological_space X] [topological_space M] [monoid M]\n  [has_continuous_mul M] {f : X \u2192 M},\n  continuous f \u2192 \u2200 (n : \u2115), continuous (\u03bb (b : X), f b ^ n)\n", "continuous_const : \u2200 {\u03b1 \u03b2 : Type} [topological_space \u03b1] [topological_space \u03b2] {b : \u03b2},\n  continuous (\u03bb (a : \u03b1), b)\n", "continuous_id : \u2200 {\u03b1 : Type} [topological_space \u03b1], continuous (\u03bb x, x)\n", "", "import tactic\n", "When given a goal that is an `\u2227` (and) of two propositions, the `split` tactic\nwill produce two goals, one for each side. That can be solved individually.\n", "", "", "import inter.level3\nimport tactic\n", "When the goal is to prove an existential, `\u2203` we can\nsupply the witness (an example that has the desired property)\nusing the tactic `use`.\n\nFor example :\nIf the goal is\n```\n\u22a2 \u2203 n : \u2115, n + 1 = 1\n```\nthen we have to take `n` to be zero, so we type `use 0`.\nThe remaining goal will then be that\n`0 + 1 = 1`\nwhich is provable with `zero_add`.\n", "", "import algebra.group.basic\nimport data.bracket\n/- # The simplifier\nUp till now we have been using `rewrite` to manually instruct Lean which steps to take one at a time.\nThis is a very useful tool, but after a while you will notice that there are some rewrites that\nwill always make things easier when substituted.\nFor example we almost always want to use the fact that multiplying by 1 or adding 0 doesn't\nchange things.\n-/\n", "\n## Summary\n\nThe `simp` tactic is a high-level tactic which tries\nto prove equalities using facts in its database.\n\n## Details\n\nThe `simp` tactic does basic automation.\nFor example, some proofs involve a tedious number of rewrites of `add_assoc` and `add_comm`, \nthe same is true of `mul_assoc` and `mul_comm` in the case of multiplication. \nWe can use `simp` to do this automatically. \nTo tell `simp` to use some lemma `h` when simplifying, write `simp[h]`. More generally, \nfor `simp` to include additional lemmas `h1`, `h2`, ..., `hn` when simplifying, write \n`simp[h1, h2, ..., hn]`. \n\n### Example:\nIf our goal is this:\n```\n\u22a2 a + b + c + d + e = a + (b + (c + d) + e)\n```\n\nwe can solve this with `simp` using `simp[add_assoc]`. \n\n### Example:\nIf our goal is this:\n```\n\u22a2 a * b * c = c * b * a\n```\n", "\n\n# Commutator identities\n\nIn these exercises we will write the proofs of the identities in\n<https://en.wikipedia.org/wiki/Commutator#Identities_(group_theory)>\nin Lean.\n\nFirst we will set up the basic definitions, in World 1, we didn't make any new mathematical\ndefinitions, we just made use of the natural numbers, propositions, and some lemmas Lean\nalready knew about.\n\n", "notation `[`x`, `y`]` := has_bracket.bracket x y -- hide\n", "definition commutator {G : Type*} [group G] (x y : G) : G := x\u207b\u00b9 * y\u207b\u00b9 * x * y\n", "instance group.has_bracket {G : Type*} [group G] : has_bracket G G := \u27e8commutator\u27e9 -- hide\n", "definition conjugate {G : Type*} [group G] (x y : G) : G := y\u207b\u00b9 * x * y\n", "instance group.has_pow {G : Type*} [group G] : has_pow G G := \u27e8conjugate\u27e9 -- hide\n", "commutator_def : [x, y] = x\u207b\u00b9 * y\u207b\u00b9 * x * y\n", "lemma commutator_def {G : Type*} [group G] {x y : G} : [x, y] = x\u207b\u00b9 * y\u207b\u00b9 * x * y := rfl\n", "conjugate_def : y^x = x\u207b\u00b9 * y * x := rfl\n", "lemma conjugate_def {G : Type*} [group G] {x y : G} : y^x = x\u207b\u00b9 * y * x := rfl\n", "inv_mul_cancel_right : \u2200 {G : Type} [_inst_1 : group G] (a b : G), a * b\u207b\u00b9 * b = a\n", "inv_mul_self : \u2200 {G : Type} [_inst_1 : group G] (a : G), a\u207b\u00b9 * a = 1\n", "Remember to check out the panel on the left for some useful lemmas\n", "", "import simplifier.level_commutator_1\n", "How far will simp get you here?\n", "namespace bloop--hide\n", "@[simp]\nlemma inv_mul_self {G : Type} [group G] (a : G) : a\u207b\u00b9 * a = 1\n", ":= mul_left_inv a --hide\n", "@[simp]\nlemma one_mul {G : Type} [group G] (a : G) : 1 * a = a\n", ":= one_mul _ --hide\n", "end bloop--hide\n", "", "import simplifier.level_commutator_2\n", "Here you might want to use `simp` together with the fact that multiplication is associative \n(this lemma is called `mul_assoc` as you might have guessed). Recall that you can tell \n`simp` to use lemma `h` when simplifying by writing `simp[h]`.  \n", "", "import simplifier.level_commutator_3\n", "", "import simplifier.level_commutator_4\n", "", "Advanced", "import topology.basic\n", "In this problem you will look at proving that the composition of two continuous maps is\ncontinuous\n\nSome things you should know:\n- A subset of a space `X` is an element of the type `set X` in Lean\n- The notation for the preimage of a set `U` along a map `f` is `f \u207b\u00b9' U`\n", "  [topological_space \u03b2] {f : \u03b1 \u2192 \u03b2},\n  continuous f \u2194 \u2200 (s : set \u03b2),is_open s \u2192 is_open (f \u207b\u00b9' s)\n", "g \u2218 f \u207b\u00b9' s = f \u207b\u00b9' (g \u207b\u00b9' s)\n", "You will need to use the tactics intros, rewrite, and apply for this problem!\nAnd some new lemmas that are in the sidebar for you.\n", "", "import topology.subset_properties\n", "In this problem you will look at proving that the image of a compact set in a topological space\nalong a continuous map is also compact.\n\nSome things you should know:\n- A subset of a space `X` is an element of the type `set X` in Lean\n- The notation for image of a set `U` along a map `f` is `f '' U`\n- The simplifier `simp,`,\n  is very useful, especially simplifying your hypotheses  `simp at ht` !\n  You can use `simp at *,` to simplify as much as possible everywhere\n- there is a new helpful lemma in the sidebar\n", "```\nrw is_compact_iff_finite_subcover, -- rewrite the definition of compactness\nrw is_compact_iff_finite_subcover at h,  -- rewrite the definition of compactness\nintros \u03b9 V hV hVu, -- we are proving a forall, so introduce everything\nobtain \u27e8t, ht\u27e9 := h (\u03bb i, f \u207b\u00b9' (V i)) _ _, -- pull back the open sets from Y to X\n```\n", "click here for the first few lines of the proof", "  [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2},\n  continuous f \u2192 \u2200 (s : set \u03b2), is_open s \u2192 is_open (f \u207b\u00b9' s)\n", ""]]}